<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dubcast – switch tracks (SoundCloud embed hidden)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <style>
        body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:32px}
        .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
        .progress{width:320px}
        /* Скрываем embed оффскрин (НЕ display:none) — иначе некоторые браузеры не играют */
        #sc-hidden{position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;border:0}
        #sc-visible{width:100%;max-width:640px;height:166px;border:0;display:none}
        #log{background:#111;color:#0f0;padding:8px;max-width:640px;white-space:pre-wrap}
    </style>
</head>
<body>
<h1>Dubcast – PoC</h1>

<label style="display:block;margin:6px 0">
    <input id="toggle" type="checkbox"> Show embed (debug)
</label>
<iframe id="sc-visible"></iframe>
<iframe id="sc-hidden" allow="autoplay"></iframe>

<div class="row">
    <button id="play">▶ Play</button>
    <button id="pause">⏸ Pause</button>
    <button id="switch">⏭ Switch track</button>
    <input id="seek" class="progress" type="range" min="0" max="100" step="0.1" value="0">
    <label>Vol <input id="vol" type="range" min="0" max="100" value="70"></label>
    <span id="time">00:00 / 00:00</span>
</div>
<div id="meta">—</div>
<pre id="log"></pre>

<script>
    const log = (...a)=>{const el=document.getElementById('log'); el.textContent += a.join(' ')+'\n'; console.log(...a);};

    // ⚠️ Берём ПУБЛИЧНЫЕ URL (надёжнее, чем дважды экранированный api-url)
    const playlist = [
        "https://soundcloud.com/suzukies/gotham-city-1", // Gotham City (2167280667)
        "https://soundcloud.com/suzukies/night-shade"    // Night Shade (2138009445)
    ];

    function makeEmbedSrc(scUrl){
        const p = new URLSearchParams({
            url: scUrl,
            auto_play: false,      // play включаем сами
            visual: false,
            show_comments: false, show_user: false, show_playcount: false,
            sharing: false, download: false, single_active: true
        });
        return `https://w.soundcloud.com/player/?${p.toString()}`;
    }

    const frameVisible = document.getElementById('sc-visible');
    const frameHidden  = document.getElementById('sc-hidden');
    const toggle       = document.getElementById('toggle');

    const btnPlay = document.getElementById('play');
    const btnPause= document.getElementById('pause');
    const btnSwitch=document.getElementById('switch');
    const seek    = document.getElementById('seek');
    const vol     = document.getElementById('vol');
    const timeEl  = document.getElementById('time');
    const metaEl  = document.getElementById('meta');

    let widget;                 // текущий управляемый виджет
    let durationMs = 0;
    let ready = false;
    let autoplayUnlocked = false; // был ли user gesture
    let idx = 0;

    function mmss(sec){sec=Math.max(0,sec|0);const m=String((sec/60|0)).padStart(2,'0');const s=String(sec%60).padStart(2,'0');return `${m}:${s}`;}

    function bindWidget(){
        ready = false; durationMs = 0; seek.value = 0; timeEl.textContent = '00:00 / 00:00'; metaEl.textContent = '—';

        widget.unbind(SC.Widget.Events.READY);
        widget.unbind(SC.Widget.Events.PLAY_PROGRESS);
        widget.unbind(SC.Widget.Events.FINISH);

        widget.bind(SC.Widget.Events.READY, () => {
            ready = true;
            widget.setVolume(parseInt(vol.value,10));
            widget.getCurrentSound(s => { if (s) metaEl.textContent = `${s.title} — ${s.user?.username ?? ""}`; });
            widget.getDuration(d => { durationMs = d||0; timeEl.textContent = `00:00 / ${mmss(durationMs/1000)}`; });
            log('READY for', playlist[idx]);
        });

        widget.bind(SC.Widget.Events.PLAY_PROGRESS, e => {
            if (!durationMs) return;
            const pct = Math.min(100, (e.currentPosition / durationMs) * 100);
            seek.value = pct;
            timeEl.textContent = `${mmss(e.currentPosition/1000)} / ${mmss(durationMs/1000)}`;
        });

        widget.bind(SC.Widget.Events.FINISH, () => {
            widget.seekTo(0); widget.pause(); seek.value = 0;
        });
    }

    function attachTo(frame){
        widget = SC.Widget(frame);
        bindWidget();
    }

    function init(){
        // грузим оба iframe, управляем скрытым по умолчанию
        frameVisible.src = makeEmbedSrc(playlist[idx]);
        frameHidden.src  = makeEmbedSrc(playlist[idx]);
        frameVisible.style.display = 'none';
        attachTo(frameHidden);

        toggle.addEventListener('change', () => {
            if (toggle.checked) {
                frameVisible.style.display = 'block';
                attachTo(frameVisible);
                log('Control → VISIBLE');
            } else {
                frameVisible.style.display = 'none';
                attachTo(frameHidden);
                log('Control → HIDDEN');
            }
            // после переключения перезагрузим текущий трек в новый контролируемый iframe
            widget.load(playlist[idx], { auto_play: autoplayUnlocked, visual:false, single_active:true });
        });

        btnPlay.addEventListener('click', () => {
            autoplayUnlocked = true;                 // user gesture получен
            if (ready) widget.play();                // если уже READY
            else log('Play pressed before READY');   // до READY заиграет после загрузки Switch/инициализации
        });

        btnPause.addEventListener('click', () => { if (ready) widget.pause(); });

        btnSwitch.addEventListener('click', () => {
            idx = (idx + 1) % playlist.length;
            // надёжнее: меняем URL внутри того же виджета
            widget.load(playlist[idx], {
                auto_play: autoplayUnlocked,  // если был user gesture — стартуем сами
                visual:false, show_comments:false, show_user:false,
                show_playcount:false, sharing:false, download:false, single_active:true
            });
            // после load обработчики остаются привязанными к тому же widget
            log('Switch →', playlist[idx]);
        });

        vol.addEventListener('input', () => { if (ready) widget.setVolume(parseInt(vol.value,10)); });
        seek.addEventListener('input', () => { if (ready && durationMs) widget.seekTo((seek.value/100) * durationMs); });
    }

    init();
</script>
</body>
</html>
п