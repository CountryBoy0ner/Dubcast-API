<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Dubcast Radio</title>

    <!-- основной стиль -->
    <link rel="stylesheet" th:href="@{/css/main.css}">
</head>
<body class="page">

<header class="header">
    <div class="header__inner">
        <a href="/" class="logo">Dubcast</a>

        <nav class="nav">
            <a href="/login" class="nav__link">Login</a>
            <a href="/register" class="nav__link">Register</a>
            <a href="/profile" class="nav__link">Profile</a>
        </nav>
    </div>
</header>

<main class="main">
    <section class="now-playing">
        <h2 class="now-playing__title">Now playing</h2>

        <div class="now-playing__content">
            <!-- Обложка -->
            <div class="now-playing__artwork-wrapper">
                <img
                        id="artwork"
                        class="now-playing__artwork"
                        src=""
                        alt="Artwork"
                        style="display: none;">
            </div>

            <!-- Информация о треке -->
            <div class="now-playing__info">
                <p id="track-title" class="now-playing__track">
                    Now playing: nothing right now.
                </p>
                <p id="playlist-title" class="now-playing__playlist">
                    Playlist: none
                </p>
            </div>
        </div>

        <!--
            Кнопка "плей/пауза" — должна быть круглой, как в аудиоплеерах.
            Дизайн и круглую форму потом задавать через CSS по классам .btn / .btn--round / .btn--active
        -->
        <div class="now-playing__controls">
            <button id="start-radio-btn" class="btn btn--primary btn--round">
                Start radio
            </button>
        </div>

        <!-- Громкость -->
        <div class="now-playing__volume">
            <label for="volume-range" class="now-playing__volume-label">Volume:</label>
            <input
                    type="range"
                    id="volume-range"
                    class="now-playing__volume-range"
                    min="0"
                    max="100"
                    step="1">
        </div>

        <!-- Debug: показывать / скрывать реальный плеер -->
        <div class="now-playing__debug">
            <label class="now-playing__debug-label">
                <input type="checkbox" id="show-player-checkbox" checked>
                Show SoundCloud player (debug)
            </label>
        </div>

        <!-- Контейнер, куда будет вставляться embed-код -->
        <div id="sc-player-wrapper" class="now-playing__player-wrapper">
            <!-- сюда js подставит iframe -->
        </div>
    </section>
</main>

<!-- SockJS + STOMP -->
<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<!-- SoundCloud Widget API -->
<script src="https://w.soundcloud.com/player/api.js"></script>

<script>
    // ----------- STATE -----------
    let radioEnabled = false;      // радио включено пользователем или нет (тоггл)
    let currentPlaylistId = null;
    let stompClient = null;
    let currentPayload = null;     // NowPlayingResponse
    let scWidget = null;           // SC.Widget
    let userVolume = 70;

    const playlistTitleEl = document.getElementById('playlist-title');
    const artworkEl = document.getElementById('artwork');
    const titleEl = document.getElementById('track-title');
    const volumeEl = document.getElementById('volume-range');
    const startBtn = document.getElementById('start-radio-btn');
    const showPlayerCheckbox = document.getElementById('show-player-checkbox');
    const playerWrapper = document.getElementById('sc-player-wrapper');

    // ----------- INIT VOLUME -----------

    (function initVolume() {
        const saved = localStorage.getItem('dubcast_volume');
        userVolume = saved != null ? parseInt(saved, 10) : 70;
        if (isNaN(userVolume)) userVolume = 70;
        volumeEl.value = userVolume;
        console.log('[VOL] initial =', userVolume);
    })();

    volumeEl.addEventListener('input', function () {
        userVolume = parseInt(this.value, 10);
        localStorage.setItem('dubcast_volume', String(userVolume));
        console.log('[VOL] change ->', userVolume);
        if (scWidget) {
            scWidget.setVolume(userVolume);
        }
    });

    // ----------- SHOW / HIDE IFRAME (debug) -----------

    showPlayerCheckbox.addEventListener('change', function () {
        playerWrapper.style.display = this.checked ? 'block' : 'none';
        console.log('[UI] toggle iframe visible =', this.checked);
    });

    // ----------- UI UPDATE -----------

    function updateUiFromPayload(payload) {
        console.log('[UI] update', payload);

        if (!payload || !payload.playing) {
            artworkEl.style.display = 'none';
            titleEl.innerText = 'Now playing: nothing right now.';
            playlistTitleEl.innerText = 'Playlist: none';
            currentPlaylistId = null;
            return;
        }

        if (payload.artworkUrl) {
            artworkEl.src = payload.artworkUrl;
            artworkEl.style.display = 'block';
        } else {
            artworkEl.style.display = 'none';
        }

        titleEl.innerText = 'Now playing: ' + (payload.title || 'unknown track');

        currentPlaylistId = payload.playlistTitle ? 1 : null; // просто пример
        if (payload.playlistTitle) {
            playlistTitleEl.innerText = 'Playlist: ' + payload.playlistTitle;
        } else {
            playlistTitleEl.innerText = 'Playlist: none';
        }
    }

    // ----------- HELPERS -----------

    function computeTrackPositionMs(payload) {
        if (!payload || !payload.startedAt || !payload.durationSeconds) {
            return 0;
        }
        const startedAtMs = Date.parse(payload.startedAt);
        if (Number.isNaN(startedAtMs)) {
            return 0;
        }
        const nowMs = Date.now();
        let elapsedSec = Math.max(0, (nowMs - startedAtMs) / 1000);
        if (elapsedSec > payload.durationSeconds - 1) {
            elapsedSec = payload.durationSeconds - 1;
        }
        const pos = Math.floor(elapsedSec * 1000);
        console.log('[POS] =', pos, 'ms from', payload.startedAt);
        return pos;
    }

    // ----------- WIDGET SETUP -----------

    function ensureWidgetIframe() {
        if (scWidget) {
            return;
        }

        const placeholderTrack = 'https://soundcloud.com/ppjrecordings/ontology-maximum-ruffness-krave-remix';

        const src = 'https://w.soundcloud.com/player'
            + '?visual=true'
            + '&url=' + encodeURIComponent(placeholderTrack)
            + '&auto_play=false';

        playerWrapper.innerHTML = `
            <iframe
                id="sc-widget"
                width="100%"
                height="450"
                scrolling="no"
                frameborder="no"
                allow="autoplay"
                src="${src}">
            </iframe>
        `;

        const iframe = document.getElementById('sc-widget');
        scWidget = SC.Widget(iframe);

        console.log('[SC] widget created with placeholder');

        scWidget.bind(SC.Widget.Events.ready, function () {
            console.log('[SC] READY');
            scWidget.setVolume(userVolume);
        });

        scWidget.bind(SC.Widget.Events.ERROR, function (e) {
            console.error('[SC] ERROR', e);
        });

        // когда трек закончился, сами узнаём, что сейчас по расписанию
        scWidget.bind(SC.Widget.Events.FINISH, function () {
            console.log('[SC] FINISH');
            if (!radioEnabled) {
                console.log('[SC FINISH] radio OFF, ignore');
                return;
            }

            fetch('/api/radio/now')
                .then(r => {
                    console.log('[SC FINISH] /api/radio/now status =', r.status);
                    return r.ok ? r.json() : null;
                })
                .then(payload => {
                    console.log('[SC FINISH] payload =', payload);
                    if (!payload || !payload.playing) {
                        console.log('[SC FINISH] nothing playing');
                        return;
                    }
                    currentPayload = payload;
                    updateUiFromPayload(payload);
                    loadAndPlayFromPayload(payload);
                })
                .catch(err => console.error('[SC FINISH] error', err));
        });
    }

    // ----------- LOAD & PLAY (фикс громкости) -----------

    function loadAndPlayFromPayload(payload) {
        if (!payload || !payload.playing) {
            console.log('[Radio] loadAndPlay: nothing playing in payload');
            return;
        }
        if (!payload.trackUrl) {
            console.error('[Radio] payload.trackUrl is missing');
            return;
        }

        ensureWidgetIframe();
        if (!scWidget) {
            console.error('[Radio] scWidget is null even after ensureWidgetIframe()');
            return;
        }

        const url = payload.trackUrl;
        const posMs = computeTrackPositionMs(payload);

        console.log('[Radio] widget.load url =', url, 'posMs =', posMs, 'userVolume =', userVolume);

        scWidget.load(url, {
            auto_play: true,
            visual: true,
            callback: function () {
                console.log('[SC] load callback, setVolume', userVolume, 'seekTo', posMs);
                scWidget.setVolume(userVolume);
                if (posMs > 0) {
                    scWidget.seekTo(posMs);
                }
            }
        });
    }

    // ----------- REST: /api/radio/now -----------

    async function fetchCurrentForUiOnly() {
        try {
            console.log('[REST] GET /api/radio/now for UI');
            const resp = await fetch('/api/radio/now');
            console.log('[REST] /api/radio/now status =', resp.status);
            if (resp.status === 204) {
                console.log('[REST] 204 No Content');
                currentPayload = null;
                updateUiFromPayload(null);
                return;
            }
            if (!resp.ok) {
                console.error('[REST] /api/radio/now error', resp.status);
                return;
            }
            const payload = await resp.json();
            console.log('[REST] initial payload', payload);
            currentPayload = payload;
            updateUiFromPayload(payload);   // только UI
        } catch (e) {
            console.error('[REST] current-for-ui error', e);
        }
    }

    // ----------- START RADIO BUTTON (TOGGLE) -----------

    startBtn.addEventListener('click', async function () {
        // переключаем состояние
        radioEnabled = !radioEnabled;

        if (!radioEnabled) {
            // ВЫКЛЮЧЕНИЕ РАДИО
            console.log('[Radio] turned OFF by user');
            startBtn.innerText = 'Start radio';
            startBtn.classList.remove('btn--active'); // визуальное состояние "не играет"
            if (scWidget) {
                scWidget.pause();
            }
            return;
        }

        // ВКЛЮЧЕНИЕ РАДИО
        console.log('[Radio] turned ON by user');
        startBtn.innerText = 'Radio is playing';
        startBtn.classList.add('btn--active'); // визуальное состояние "играет"

        try {
            if (!currentPayload) {
                console.log('[Radio] no currentPayload, fetch now');
                const resp = await fetch('/api/radio/now');
                console.log('[Radio] /api/radio/now (start) status =', resp.status);
                if (resp.status === 204 || !resp.ok) {
                    console.log('[REST] no current track on start');
                    // откатываем состояние, т.к. по факту ничего не играет
                    radioEnabled = false;
                    startBtn.innerText = 'Start radio';
                    startBtn.classList.remove('btn--active');
                    return;
                }
                currentPayload = await resp.json();
            }

            updateUiFromPayload(currentPayload);
            // ВАЖНО: при каждом включении пересчитываем позицию по startedAt
            loadAndPlayFromPayload(currentPayload);
        } catch (e) {
            console.error('[Radio] start-radio exception', e);
            // на всякий случай откат кнопки
            radioEnabled = false;
            startBtn.innerText = 'Start radio';
            startBtn.classList.remove('btn--active');
        }
    });

    // ----------- WS / STOMP -----------

    function connectWs() {
        console.log('[WS] Opening Web Socket...');
        const socket = new SockJS('/radio-ws');
        stompClient = Stomp.over(socket);
        // stompClient.debug = null;

        stompClient.connect({}, function (frame) {
            console.log('[WS] connected:', frame);

            stompClient.subscribe('/topic/now-playing', function (message) {
                const payload = JSON.parse(message.body);
                console.log('[WS] now-playing payload', payload);
                handleNowPlaying(payload);
            });
        }, function (error) {
            console.error('[WS] error', error);
        });
    }

    function handleNowPlaying(payload) {
        console.log('[WS] handleNowPlaying', payload);
        currentPayload = payload;
        updateUiFromPayload(payload);

        if (!radioEnabled) {
            console.log('[Radio] OFF, just update UI (no sound)');
            return;
        }
        if (!payload.playing) {
            console.log('[Radio] payload says nothing playing');
            return;
        }

        loadAndPlayFromPayload(payload);
    }

    // ----------- STARTUP -----------

    window.addEventListener('load', () => {
        console.log('[BOOT] Page loaded, init WS + fetch current');
        connectWs();
        fetchCurrentForUiOnly();
    });
</script>

</body>
</html>
