# Documentation Strategy for Dubcast Radio API

This document explains **how the Dubcast Radio API documentation is organized and maintained**:
tools, standards, conventions, and known limitations. It is written to match the **current API**
(as implemented now), without changing application code.

---

## 1. Purpose

The documentation set aims to provide:

- a **validated API reference** (endpoints, parameters, request/response formats)
- **authentication & authorization rules** (JWT + roles)
- a **consistent error format** and recovery hints
- practical **examples and tutorials** (copy‑paste friendly)
- **high-level architecture** to understand API modules and request flow
- a clear **versioning policy** (documentation + future API evolution)

---

## 2. Tools and Formats

### 2.1 OpenAPI Specification (source of truth)

- **OpenAPI version:** 3.1
- **Generated by:** Springdoc OpenAPI from controller annotations
- **Published via:** Swagger UI + JSON/YAML export

Artifacts in the repository:

- `docs/schemas/openapi.json` — machine-readable spec (generated / exported)
- `docs/schemas/openapi.yaml` — exported version for human readability

Validation workflow:

- **Swagger Editor** — schema validation and visual inspection
- **(Optional) Spectral / Redocly CLI** — linting for best practices

> Note: The current API paths are versionless (e.g. `/api/auth/login`, not `/api/v1/...`).
> Versioning rules are described separately in `docs/reference/api-versioning.md`.

### 2.2 Markdown Documentation

Markdown is used for all narrative docs:

- easy to review in GitHub/GitLab
- supports code blocks, diagrams (ASCII/Mermaid), and tables
- suitable for publishing with GitBook/Docusaurus later

---



## 4. Conventions

### 4.1 Endpoints

- lowercase
- REST-style nouns where applicable (`/api/users`, `/api/tracks`, `/api/playlist`)
- nested paths for admin operations (`/api/admin/...`)
- base prefix for REST API: `/api`

### 4.2 JSON and DTO conventions

- JSON fields use **camelCase**
- DTO / schema names use **PascalCase** (e.g., `UserDto`, `ScheduleEntryDto`)
- examples are formatted with **2 spaces**, no trailing commas

### 4.3 Security and roles

- JWT bearer tokens via `Authorization: Bearer <token>`
- role-based access is enforced by Spring Security:
    - public endpoints: e.g. radio/programming/chat read endpoints
    - protected endpoints: profile + admin APIs
    - admin-only endpoints: users/tracks/schedule/admin programming

---

## 5. Versioning Approach (current reality)

- Current public API is treated as **Version 1 (v1)** conceptually.
- **No `/api/v1` prefix is used in the current implementation**.
- The OpenAPI `info.version` is used to communicate the public API version (`v1`).

If a breaking change is required later, the plan is to introduce `/api/v2/...` routes
(or a different explicit versioning method) while keeping old routes for a transition period.

---

## 6. Error Handling & Consistency Rules

All API errors should return a single unified structure described in:

- `docs/reference/error-handling.md`

Key goals:

- no raw HTML error pages for API routes
- consistent JSON errors for: 400/401/403/404/409/500
- validation errors include `validationErrors` map (field → message)

---

## 7. What is “done” vs “may evolve”

Stable parts:

- authentication flows (`/api/auth/*`)
- public radio/programming endpoints
- error response format and security errors

Likely-to-evolve parts:

- admin programming operations as admin UI grows
- analytics and realtime features (WebSocket, streaming-related endpoints)
- additional pagination/filtering parameters

---

## 8. Maintenance Process

1. Update controller annotations / DTO schemas in code
2. Regenerate / export OpenAPI (`openapi.json` / `openapi.yaml`)
3. Validate with Swagger Editor (and optionally lint with Spectral)
4. Update Markdown guides/examples if behavior changed
5. Commit everything together so docs and code stay in sync

---

## 9. Summary

This strategy ensures:

- consistent and navigable docs
- validated OpenAPI specification
- clear guides and runnable examples
- maintainable structure aligned with current API behavior
